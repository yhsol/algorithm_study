# 빅오, 자료형

## 빅오

> 빅오(O, big-O)란 입력값이 무한대로 향할때 함수의 상한을 설명하는 수학적 표기 방법이다.

- 관심의 대상이 되는 것은 입력의 크기가 충분히 클 때다.
  충분히 큰 입력에서는 알고리즘의 효율성에 따라 수행 시간이 크게 차이가 날 수 있다.

### 상한과 최악

> 빅오 표기법은 주어진(최선/최악/평균)경우의 수행 시간의 상한을 나타낸다.

### 분할 상환 분석

> 시간 또는 메모리를 분석하는 알고리즘의 복잡도를 계산할 때,
> 알고리즘 전체를 보지 않고 최악의 경우만을 살펴보는 것은 지나치게 비관적이라는 이유로
> 분할 상환 분석 방법이 등장하는 계기가 됐다.

### 병렬화

일부 알고리즘들은 병렬화로 실행 속도를 높일 수 있다.

> GPU 각각의 코어는 CPU보다 훨씬 더 느리지만 GPU의 코어는 수천여 개로 구성되어 있어,
> 많아 봐야 수십여 개에 불과한 CPU보다 수백 배 더 많은 연산을 동시에 수행할 수 있다.

> 이처럼 딥러닝 알고리즘을 비롯해 병렬 연산이 가능한 알고리즘들은 최근에 큰 주목을 받고 있다.  
> 알고리즘 자체의 시간 복잡도 외에도 알고리즘이 병렬화가 가능한지는 근래에 알고리즘의 우수성을 평가하는  
> 매우 중요한 척도 중 하나이기도 하다.

## 자료형

### 파이썬 자료형

#### 숫자

- 파이썬에서는 숫자 정수형으로 int만을 제공
- PEP 237을 통해 버전 2.4부터는 int가 충분하지 않으면 자동으로 long 타입으로 변경되는 구조가 됐으며 덕분에 C와 달리  
  오버플로(Overflow)가 발새하는 일은 사라졌다.  
  PEP 237 로드맵에 따라 버전 3부터는 아예 int 단일형으로 통합됐다.

- int는 임의 정밀도를 지워하며, 더 이상 파이썬에서 고정 정밀도 정수형은 지원하지 않게 됐다.

  - 임의 정밀도
    - 무제한 자릿수를 제공하는 정수형
    - 정수를 숫자의 배열로 간주. 자릿수 단위로 쪼개어 배열 형태로 표현
    - 자릿수 단위로 구분한 값을 별도로 계산하여 처리
    - 임의 정밀도로 처리하면 계산 속도가 저하된다.
    - 그러나 숫자를 단일형으로 처리할 수 있으므로 언어를 매우 단순한 구조로 만들 수 있을 뿐만 아니라,
      언어를 사용하는 입장에서도 더 이상 오버플로를 고민할 필요가 없어 잘못된 계산 오류를 방지할 수 있다.
    - 기능과 안전을 위해 속도를 맞바꾼 셈
    - 파이썬의 경우에는 기본 정수형인 int가 임의 정밀도 연산까지 수행한다.
      - (hs: Rust에서는 숫자에 대한 다양한 타입이 있다. 그런 타입들도 속도에 도움이 되나보다.)

- bool
  - bool은 엄밀히 따지면 논리 자료형인데 파이썬에서는 내부적으로  
    1(True)과 0(False)으로 처리되는 int의 서브 클래스다.  
    int는 object의 하위 클래스이기도 하기 때문에 결국 다음과 같은 구조를 띈다.
    ```
    object > int > bool
    ```
    논리 자료형의 값인 True와 정수형의 값인 1을 비교해보면 다음과 같다.
    ```
    >>> True == 1
    True
    >>> False == 0
    True
    ```
    비교 연산자 ==를 통해 확인한 결과 논리 자료형은 내부적으로 정수값을 갖고 있는 것을 확인할 수 있다.

#### 매핑

- 키와 자료형으로 구성된 복합 자료형
- 파이썬에 내장된 유일한 매핑 자료형은 딕셔너리

#### 집합

- 파이썬의 집합 자료형인 set은 중복된 값을 갖지 않는 자료형
- ## 선언

  ```
  >>> a = set()
  >>> a
  set()
  >>> type(a)
  <class 'set'>
  ```

- 빈 집합이 아닌 값이 포함된 집합을 선언할 때는 a = {1, 2, 3} 형태로 하는데,
  집합은 딕셔너리와 동일하게 중괄호({})를 사용하므로 이 점에 유의
- 구분
  - 딕셔너리는 키(Key)/값(Value) 형태이지만
    집합은 값만 선언하므로 선언 형태를 보면 타입 판단 가능
  - 동일한 방식으로 파이썬 컴파일러는 타입 결정을 자동으로 한다.
  ```
  >>> a = {'a', 'b', 'c'}
  >>> type(a)
  <class 'set'>
  >>> a = {'a': 'A', 'b': 'B', 'c': 'C'}
  >>> type(a)
  <class 'dict'>
  ```
  - set은 입력 순서가 유지되지 않으며, 다음처럼 중복된 값이 있을 경우 하나의 값만 유지한다.
    ```
    >>> a ={3, 2, 3, 5}
    >>> a
    {2, 3, 5}
    ```

#### 시퀀스

- 시퀀스(Sequence)는 우리말로 하면 '수열' 같은 의미로, 어떤 특정 대상의 순서 있는 나열을 뜻한다.
- 예를 들어 str은 문자의 순서 있는 나열로 문자열을 이루는 자료형이며,  
  list는 다양한 값들을 배여 형태의 순서 있는 나열로 구성하는 자료형이다.
- 파이썬에서는 list라는 시퀀스 타입이 사실상 배열의 역할을 수행한다.
- 시퀀스는 qnfqus(Immutable)과 가변(Mutable)으로 구분하는데 말 그대로 불변은 값을 변경할 수 없다.
- 불변
  - str, tuple, bytes
    - 'str 변수는 값을 변경할 수 있는데?' 라는 의문이 들 수 있다. 다음 코드를 살펴보자.
    ```
    >>> a = 'abc'
    >>> a = 'def'
    >>> type(a)
    <class 'str'>
    ```
        - a 변수는 str 자료형인데 처음에 abc 를 할당했다가 이후에 def를 할당했다.
          a 변수의 값이 변경된 셈이다. 그런데 str은 값이 변경되지 않는 불변이라는 건 과연 무슨 의미일까?
          - 다소 혼동될 수 있는 내용인데 여기서 맨 처음에 a 변수에 할당된 str타입인 abc는 변경된 적이 없다.
            불젼이다. 이후에 a 변수는 다른 str 타입인 def를 다시 참조했을 뿐 실제로 abc도, def도 한번 생성된 후에 변경된 적이 없다.
            불변이므로 변경될 수도 없다. 그렇다면 다음 코드를 살펴보자.
            ```
            >>> a = 'abc'
            >>> id('abc')
            4317530408
            >>> id(a)
            4317530408
            >>> a = 'def'
            >>> id('def)
            4318831648
            >>> id(a)
            4318831648
            ```
            각각의 메모리 주소를 출력해보면 a 변수는 처음에는 abc를 참조했다가(같은 주소)
            이후에는 def를 참조하도록(같은 주소) 변경되었을 뿐이다.
            abc와 def는 생성된 후에 변하지않고 메모리 어딘가에 남아 있다.
            str이 정말로 변경되려면 참조하고 있는 str에 대해 다음과 같은 할당자가 처리되어야 하는데 여기서는 오류가 발생한다.
            ```
            >>> a[1] = 'd'
            Traceback (most recent call last):
              File "<stdin>", line 1, in <module>
            TypeError: 'str' object does not support item assignment
            ```
            이처럼 str은 변경할 수 없으며, 불변이다.
            반면 list는 가변이다. 이 말은 쉽게 이해된다.
            리스트는 자유롭게 값을 추가, 삭제할 수 있는 동적 배열이다.

### 원시 타입

원시 타입은 메모리에 정확하게 타입 크기만큼의 공간을 할당하고 그 공간을 오로지 값으로 채워넣는다.
C뿐만 아니라 자바도 마찬가지다. 원시 타입을 제공하며 매우 빠른 연산이 가능하다.
자바는 원시 타입에 대응되는 클래스 객채(Object)를 다음과 같이 지원한다.

```
Integer a = new Integer(5)
```

원시 타입을 객체로 변환하면 여러가지 작업을 수행할 수 있게 된다.
객체는 편리하고 다양한 기능을 제공하기 위해 일정 부분 속도와 공간을 희생하게 된다.

> 파이썬은 원시 타입을 지원하지 않는다.

파이썬은 애초에 편리한 기능 제공에 우선순위를 둔 언어인 만큼
느린 속도와 더 많은 메모리를 차지하더라도 훨씬 더 다양한 기능을 제공할 수 있는
객체에 관심을 두는 게 어찌 보면 당연하다.
파이썬은 원시 타입의 속도를 포기하는 대신 객체의 다양한 기능과 편의성을 택했다.
(hs: 그래서 `type(1)`을 해보면 `<class 'int'>`의 형태가 되는구나.)

#### 객체

파이썬은 모든 것이 객체다.
불변 객체(Immutable Object)와 가변 객체(Mutable Object)로 구분할 수 있다.
|클래스|설명|불변 객체|
|bool|부울|o|
|int|정수|o|
|float|실수|o|
|list|리스트|x|
|tuple|리스트와 튜플의 차이는 불변 여부이며 이외에는 거의 동일하다.  
튜플은 불변이므로 생성할 때 설정한 값은 변경할 수 없다.|o|
|str|문자|o|
|set|중복된 값을 갖지 않는 집합 자료형|x|
|dict|딕셔너리|x|

##### 불변 객체

- 파이썬은 모든 것이 객체
- 파이썬에서 변수를 할당하는 작업은 해당 객체에 대해 참조를 한다는 의미
- 여기에는 예외가 없으며 심지어 문자와 숫자도 모두 객체

```
>>> 10
>>> a = 10
>>> b = a
>>> id(10), id(a), id(b)
(4393858752, 4393858752, 4393858752)
```

10이라는 숫자가 있다. 이제 이 10을 a 변수에 할당했다. 그리고 b 변수는 a 변수를 할당 했다.
만약 모두 원시 타입이라면 각각의 값들은 각 메모리의 다른 영역에 위치할 것이다.
그러나 파이썬은 모든 것이 객체이므로, 메모리 상에 위치한 객체의 주소를 얻어오는 id() 함수를 실행한 결과는 놀랍게도 모두 동일하다.
만일 10이 11이 된다면 a 변수와 b 변수 모두 값이 11로 바뀌게 될 것이다.
그러나 그런 일은 일어나지 않는다. 숫자와 문자는 모두 불변 객체이기 때문이다.
이제 앞서 str이 불변 객체라 얘기했던게 무슨 말인지 이해될 것이다.
값을 담고 있는 변수는 사실은 참조일 뿐이고 실제로 값을 갖고 있는 int와 str은 모두 불변 객체다.
이외에도 불변 객체로 tuple이 있다.
말 그대로, 한번 ㄱ밧을 담아두면 더 이상 값을 변경할 수 없다.
상수처럼 read-only 용도로 사용하거나 무엇보다 값이 변하지 않기 때문에
dict의 키나 set의 값으로도 사용할 수 있다.
list는 언제든 값이 변할 수 있기 때문에 dict의 키로 정하거나 set의 값으로는 추가할 수 없다.

##### 가변 객체

- 리스트
- int, str과 달리 list는 값이 바뀔 수 있으며, 이 말은 다른 변수가 참조하고 있을 때 그 변수의 값 또한 변경된다는 얘기다.

```
>>> a = [1, 2, 3, 4, 5]
>>> b = a
>>> b
[1, 2, 3, 4, 5]
>>> a[2] = 4
>>> a
[1, 2, 4, 4, 5]
>>> b
[1, 2, 4, 4, 5]
```

변수 a는 list다. b에는 a를 할당하여 참조가 되게 했다.
이제 list인 a의 요소 하나를 조작해서 값을 변경했다.
그렇다면 b의 값은 어떻게 될까?
위 코드에서 확인할 수 있는 것처럼 그에 따라서 b의 값이 변경됐다.
만약 b가 int나 str을 참조하고 있다면 불변 객체이기 때문에 절대 이런 일이 일어나지 않겠지만,
list는 가변 객체이기 때문에 얼마든지 일어날 수 있다.

## 문법 is와 ==

- is는 id() 값을 비교하는 함수
- None은 널(null)로서 값 자체가 정의되어 있지 않으므로 ==로 비교가 불가능하다.
  따라서 다음과 같이 is로만 비교가 가능하다.
  ```py
  if a is None:
      pass
  ```
- ==는 값을 비교하는 연산자.
- 다음과 같이 리스트를 생성해서 비교해보면 ==와 is이 차이에 대해서 금방 이해가 될 것이다.

```
>>> a = [1, 2, 3]
>>> a == a
True
>>> a == list(a)
True
>>> a is a
True
>>> a is list(a)
False
```

값은 동일하지만 list()로 한 번 더 묶어주면, 별도의 객체로 복사가 되고 다른 ID를 갖게 된다.
따라서 `is`는 `False`가 된다.

```
>>> a = [1, 2, 3]
>>> a == copy.deepcopy(a)
True
>>> a is copy.deepcopy(a)
False
```

`copy.deepcopy()`로 복사한 결과 또한 값은 같지만 ID는 다르기 때문에,
==로 비교하면 True, is로 비교할 경우 False가 된다.

##### 속도

파이썬의 객체 구조는 잘 설계되어 있고 매우 편리하고 강력한 기능을 제공한다. 문제는 속도다.

- 파이썬의 객체는 값을 꺼내는 데만 해도 여러 단계의 부가 작업이 필요하다.
- 파이썬의 과학 계산 모듈인 넘파이(NumPy)는 빠른 속도로도 유명한데,
  넘파이는 C로 만든 모듈이며 내부적으로 리스트를 C의 원시 타입으로 처리하기 때문이다.

## 참고 자료구조, 자료형, 추상 자료형

- 자료구조 (Data Structure)
  - 데이터에 효율적으로 접근하고 조작하기 위한 데이터의 조직, 관리, 저장 구조를 말한다.
- 자료형 (Data Type)
  - 컴파일러 또는 인터프리터에게 프로그래머가 데이터를 어떻게 사용하는지를 알려주는 일종의 데이터 속성(Attribute)이다.
  - 자료형은 자료구조에 비해 훨씬 더 구체적이며,
    특정 언어에서 자료형이라 함은 정수(Integer), 실수(Floating-Point Number), 문자열(String) 등
    해당 언어에서 지원하는 원시 자료형(Primitive Data Type)까지 포함하는 모든 자료의 유형을 말한다.
- 자료구조는 일반적으로 원시 자료형을 기반으로 하는 배열, 연결 리스트, 객체(Object) 등을 말하며,
  자료형의 관점에서 보자면 여러 원시 자료형을 조합한 자료구조는 복합 자료형(Composite Data Type)이 된다.
- 추상 자료형 (Abstract Data Type)
  - 줄여서 ADT
  - 행동만을 정의할 뿐 실제 구현 방법은 명시하지 않는다.
  - 객체 지향 프로그래밍(OOP)에 대한 경험이 있는 분들이라면 추상화(Abstraction)를 떠올리면 이해하기 쉬울 것이다.
  - 추상화는 필수적인 속성만 보여주고, 불필요한 정보는 감추는 것을 의미하는데
    이처럼 인터페이스만 보여주고 실제 구현은 보여주지 않는다는 점에서 ADT는 OOP의 추상화와 비슷한 개념이라 할 수 있다.
