# 문자열 조작

1.  유효한 팰린드롬
    문제: 주어진 문자열이 팰린드롬인지 확인하라. 대소문자를 구분하지 않으며, 영문자와 숫자만을 대상으로 한다.

        - 풀이 1:
          풀이: - 전처리

              ```py
              strs = []
              for char in s:
                  if char.isalnum():
                      strs.append(char.lower())
              ```

                  - 여기서 isalnum()는 영문자, 숫자 여부를 판별하는 함수로,
                    이를 이용해 해당하는 문자만 추가
                  - 대소문자를 구분하지 않으므로 lower()로 모두 소문자로 변환

              - 이제 다음과 같이 팰린드롬 여부를 판별해보자.

              ```py
              while len(strs) > 1:
                  if strs.pop(0) != strs.pop():
                      return False
              ```

              모두 통과했다면 True 를 리턴한다.

        - 풀이 2:
          데크 자료형을 이용한 최적화

          ```py
          def isPalindrome(self, s: str) -> bool:
              # 자료형 데크로 선언
              strs: Deque = collections.deque()

              for char in s:
                  if char.isalnum():
                      strs.append(char.lower())

              while len(strs) > 1:
                  if strs.popleft() != strs.pop():
                      return False

              return True
          ```

          - 풀이 #1 대비 거의 5배 가까이 더 속도를 높일 수 있었다.
            이는 리스트의 pop(0)이 O(n)인 데 반해, 데크의 popleft()는 O(1)이기 때문이다. 각각 n번씩 반복하면, 리스트 구현은 O(n\*\*2), 데크 구현은 O(n)으로 성능 차이가 크다.

        - 풀이 3:
          슬라이싱을 이용한 문제 풀이 코드

          ```py
          def isPlalindrome(self, s: str) -> bool:
              s = s.lower()
              # 정규식으로 불필요한 문자 필터링
              s = re.sub('[^a-z0-9]', '', s)

              return s == s[::-1] # 슬라이싱
          ```

          여기서는 별달리 알고리즘이라 부를 만한 게 없다.
          정규식으로 불필요한 문자를 필터링하고, 문자열을 조작할 수 있는 파이썬의 슬라이싱(Slicing)을 사용했다. 앞서 풀이에서는 isalnum()으로 모둔 문자를 일일이 점검했다.

          여기서는 문자열 전체를 한 번에 영숫자(Alphanumeric)만 걸러내도록 정규식으로 처리했다.
          또한 파이썬은 문자열을 배열이나 리스트처럼 자유롭게 슬라이싱할 수 있는 좋은 기능을 제공하며,
          [::-1]을 이용하면 뒤집을 수 있다.
          코드가 훨씬 더 줄어듦은 물론, 내부적으로 C로 빠르게 구현되어 있어 훨씬 더 좋은 속도를 기대할 수 있다.
          이 경우 실행 속도은 36밀리초로, 앞선 풀이 #2에 비해 약 2배 정도 더 속도를 높일 수 있었다.

## 문법 문자열 슬라이싱

- ## '안녕하세요'
  ```
  0  1  2  3  4
  안 녕 하 세 요
  -5 -4 -3 -2 -1
  ```
  - S[1:4] == 녕하세:  
     인덱스 1에서(0부터 시작) 4 이전까지(4는 포함하지 않는다) 표현한다.
    4개를 의미하는 게 아니므로 유의
  - S[1:-2] == 녕하:  
     인덱스 1에서 -2 이전까지(-2는 포함하지 않는다) 표현한다.
    뒤에서부터는 음수로 접근이 가능하다.
  - S[1:] == 녕하세요:  
     문자열의 시작 또는 끝은 생략 가능하다.
  - S[:] == 안녕하세요:  
     둘 다 생략하면 사본을 리턴한다.
    파이썬은 a = b와 같은 형태로 할당하면 변수의 값이 할당되는 것이 아니라 a 변수가 b 변수를 참조하는 형태가 된다.
    참조가 아닌 값을 복사하기 위해 [:]를 사용할 수 있으며,
    이 방식은 문자열이나 리스트를 복사하는 파이썬다운 방식(Pythonic Way)이기도 하다.
  - S[1:100] == 녕하세요:  
     인덱스가 지나치게 클 경우 문자열의 최대 길이만큼만 표현된다.
    S[1:]과 동일하다.
  - S[-1] == 요: 마지막 문자(뒤에서 첫번째)
  - S[-4] == 녕: 뒤에서 4번째
  - S[:-3] == 안녕: 뒤에서 3개 글자 앞까지
  - S[-3:] == 하세요: 뒤에서 3번재 문자에서 마지막까지
  - S[::1] == 안녕하세요: 1은 기본값으로 동일하다.
  - S[::-1] == 요세하녕안: 뒤집는다.
  - S[::2] == 안하요: 2칸씩 앞으로 이동한다.

2. 문자열 뒤집기
   문제: 문자열을 뒤집는 함수를 작성하라. 입력값은 문자 배열이며, 리턴 없이 리스트 내부를 직접 조작하라.
