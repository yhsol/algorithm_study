# 리스트, 딕셔너리

## 리스트

- 순서대로 저장하는 시퀀스이자 변경 가능한 목록(Mutable List)을 말한다.
- 입력 순서 유지
- 내부적으로는 동적 배열로 구현
- 각 언어별 동적 배열 구현

  ```
  |언어|동적 배열|
  |파이썬|list()|
  |C++|std:vector|
  |자바|ArrayList|
  ```

- 리스트를 사용하면 사실상 스택을 사용할지, 큐를 사용할지를 고민하지 않아도 됨.
- 스택과 큐에서 사용 가능한 모든 연산을 함께 제공한다.
- 이는 코딩 테스트 시 매우 유리한 조건
- O(1) 에 실행 가능한 연산들도 몇 가지 있다.
  - append, pop, 조회
- pop(0)는 O(n)이다. 따라서 리스트에 주로 큐의 연산을 사용할 때는 주의가 필요하다.
  이 경우 데크(Deque) 같은 자료형으로 성능을 높일 수 있다.

- 리스트의 주요 연산과 시간 복잡도 표
  |연산|시간 복잡도|설명|
  |len(a)|O(1)|전체 요소의 개수를 리턴한다.|
  |a[i]|O(1)|인덱스 i의 요소를 가져온다.|
  |a[i:j]|O(k)|i부터 j가지 슬라이스의 길이만큼인 k개의 요소를 가져온다. 이 경우 객체 k개에 대한 조회가 필요하므로 O(k)이다.|
  |elem in a|O(n)|elem 요소가 존재하는지 확인한다. 처음부터 순차 탐색하므로 n만큼 시간이 소요된다.|
  |a.cound(elem)|O(n)|elem 요소의 개수를 리턴한다.|
  |a.index(elem)|O(n)|elem 요소의 인덱스를 리턴한다.|
  |a.append(elem)|O(1)|리스트 마지막에 elem 요소를 추가한다.|
  |a.pop()|O(1)|리스트 마지막 요소를 추출한다. 스택의 연산이다.|
  |a.pop(0)|O(n)|리스트 첫번째 요소를 추출한다. 큐의 연산이다.
  이 경우 전체 복사가 필요하므로 O(n)이다.
  나중에 다시 살펴보겠지만 큐의 연산을 주로 사용한다면 리스트보다는
  O(1)에 가능한 데크(deque)를 권장한다.|
  |del a[i]|O(n)|i에 따라 다르다. 최악의 경우 O(n)이다.|
  |a.sort()|O(n log n)|정렬한다. 팀소트(Timsort)를 사용하며,
  최선의 경우 O(n)에도 실행될 수 있다.|
  |min(a), max(a)|O(n)|최솟값/최댓값을 계산하기 위해서는 전체를 선형 탐색해야 한다.|
  |a.reverse()|O(n)|뒤집는다. 리스트는 입력 순서가 유지되므로 뒤집게 되면 입력 순서가 반대로 된다.|

### 리스트의 활용 방법

- 선언

  - `>>> a = list()`
  - `>>> a = []`

- 초깃값 지정 또는 append()로 추가

```
>>> a = [1, 2, 3]
>>> a
[1, 2, 3]
>>> a.append(4)
>>> a
[1, 2, 3, 4]
```

- insert() 함수를 사용해 특정 위치의 인덱스를 지정해 요소 추가

  ```
  >>> a.insert(3, 5)
  >>> a
  [1, 2, 3, 5, 4]
  ```

- 숫자 외에도 다양한 자료형을 단일 리스트에 관리할 수 있어 매우 편리

  ```
  >>> a.append('안녕')
  >>> a.append(True)
  >>> a
  [1, 2, 3, 5, 4, '안녕', True]
  ```

- 꺼내올 때

  ```
  >>> a[3]
  5
  ```

- 슬라이싱(Slicing)

  - 특정 범위 내의 값을 매우 편리하게 가져올 수 있다.
  - 원래 슬라이싱은 문자열에 유용하게 활용되는 기능으로서,
    리스트에도 동일한 형태로 매우 유용하게 활용할 수 있다.
  - 인덱스 1에서 인덱스 3 이전까지의(인덱스 3은 포함되지 않는다) 값을 가져와 보자.

  ```
  >> a[1:3]
  [2, 3]
  ```

  - 시작 인덱스는 다음과 같이 생략할 수 있다.
    ```
    >>> a[:3]
    [1, 2, 3]
    ```
  - 종료 인덱스를 생략할 수 있다.
    ```
    >>> a[4:]
    [4, '안녕', True]
    ```
  - 다음과 같이 홀수 번재 인덱스의 값만 가져올 수도 있다.

  ```
  # 인덱스 1, 2, 3의 값
  >>> a[1:4]
  [2, 3, 5]
  # 인덱스 1, 3의 값
  >>> a[1:4:2]
  [2, 5]
  ```

  - 원래 [1:4]는 인덱스 1, 2, 3의 값을 가져오지만 이처럼 세 번째 파라미터를 부여하면 단계(Step)의 의미로,
    [1:4:2]와 같이 단계를 2로 지정할 경우 두 칸씩 건너뛰게 된다.
    즉 인덱스 1부터 시작해 1에서 두 칸 거너뛴 3까지의 값을 가져오게 된다.

- 존재하지 않는 인덱스를 조회할 경우 IndexError 발생

```
>>> a[9]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: list index out of range
```

IndexError는 인덱스가 리스트의 길이를 넘어설 때 발생하며,
다음과 같이 try 구문으로 에러에 대한 예외 처리를 할 수 있다.

```
try:
    print(a[9])
except IndexError:
    print('존재하지 않는 인덱스')
```

- 리스트에서 요소를 삭제하는 방법은 크게 2가지

  - 인덱스로 삭제
    - del 키워드 사용
    ```
    >>> a
    [1, 2, 3, 5, 4, '안녕', True]
    >>> del a[1]
    >>> a
    [1, 3, 5, 4, '안녕', True]
    ```
  - 값으로 삭제

    - remove() 함수를 사용

    ```
    >>> a
    [1, 3, 5, 4, '안녕', True]
    >>> a.remove(3)
    >>> a
    [1, 5, 4, '안녕', True]
    ```

  - pop() 함수를 사용
    - 스택의 팝(pop) 연산처럼 추출로 처리
    - 즉 삭제될 값을 리턴하고 삭제가 진행 됨.
    ```
    >>> a
    [1, 5, 4, '안녕', True]
    >>> a.pop(3)
    '안녕'
    >>> a
    [1, 5, 4, True]
    ```

### 리스트의 특징

- 파이썬의 리스트는 배열과 연결 리스트를 합친 듯이 강력한 기능을 자랑한다.
- 다음은 정수로 이뤄진 값들을 파이썬 리스트에 삽입하는 코드다.

```
>>> a = [1, 2, 3]
>>> a
[1, 2, 3]
```

일반적으로 정수형 배열이라고 하면,
이처럼 정수로만 이뤄진 값을 연속된 메모리 공간에 저장하는 경우를 말하며,
정수가 아닌 값은 저장할 수 없다.
그러나 파이썬의 리스트는 연결 리스트에 대한 포인터 목록을 관리하고 있기 때문에
앞서 '리스트의 활용 방법'절에서 살펴본 것처럼
다음과 같이 정수, 문자, 불리언 등 제각기 다양한 타입을 동시에 단일 리스트에서 관리하는 게 가능하다.

```
>>> a = [1, '안녕', True]
>>> a
[1, '안녕', True]
```

- 이러한 특징은 매우 강력하며 매우 편리하게 활용할 수 있다.
  그러나 각 자료형의 크기는 저마다 서로 다르기 때문에 이들을 연속된 메모리 공간에 할당하는 것은 불가능하다.
  결국 각각의 객체에 대한 참조로 구현할 수밖에 없다.
  당연히 인덱스를 조회하는 데에도 모든 포인터의 위치를 찾아가서 타입 코드를 확인하고
  값을 일일이 살펴봐야 하는 등 추가적인 작업이 필요하기 때문에,
  속도 면에서도 훨씬 더 불리하다.
  이처럼 파이썬은 강력한 기능을 위해 리스트와 객체에 대한 참조를 택했으며,
  이로 인해 부득이하게 속도를 희생한 측면이 있다.

## 딕셔너리
