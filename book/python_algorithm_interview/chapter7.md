# 배열

**배열은 값 또는 변수 엘리먼트의 집합으로 구성된 구조로,
하나 이상의 인덱스 또는 키로 식별된다.**

자료구조는 크게 메모리 공간 기반의 연속(Contiguous) 방식과
포인터 기반의 연결(Link) 방식으로 나뉜다.
배열은 이 중에서 연속 방식의 가장 기본이 되는 자료형이다.
연결 방식의 가장 기본이 되는 자료형은 바로 다음 8장에서 살펴보게될 '연결 리스트'다.
추상 자료형(Abstract Data Type) (이하 ADT)의 실제 구현 대부분은
배열 또는 연결 리스트를 기반으로 한다.
예를 들어 스택은 연결 리스트로 구현하고,
큐는 배열로 구현하는 식이다.
물론 반대의 경우도 충분히 가능하다.

오늘날 32비트 이상의 시스템에서는 int를 4바이트로 사용한다.
메모리에 대한 접근은 바이트 단위로 한다.
따라서 가리키는 주소는 1바이트마다 1씩 증가한다.

배열은 어느 위치에나 O(1)에 조회가 가능하다는 장점이 있다.
예를 들어 그림 7-1의 배열에서 4번재 값에 접근하고 싶다면 int 배열이므로
각각 4바이트,
즉 (4-1)\*4=12 가 되고,
0x00에서 시작해 12만큼 증가한 16진수는 0x0C가 된다.
이제 이 주소를 찾으면 해당 메모리에 배치되어 있는 값 0을 바로 읽어올 수 있다.
배열이 5개가 아니라 1억개라도 마찬가지다.
즉시 주소를 계산할 수 있고, 언ㅇ제든 해당 메모리 주소에 있는 값을 O(1)에
조회가 가능하다.

앞서 배열이란 고정된 크기만큼의 연속된 메모리 할당이라고 설명했다.
그러나 실제 데이터에서는 전체 크기를 가늠하기 힘들 때가 많다.
그렇다면 미리 크기를 지정하지 않고 자동으로 조정할 수 있다면 좋지 않을까?
이러한 고민을 해결하고자 크기를 지정하지 않고 자동으로 리사이징하는 배열인 동적 배열이 등장했다.

대부분의 프로그래밍 언어는 동적 배열을 지원
자바 - ArrayList
C++ - std::vector
파이썬 - 리스트
대부분의 동적 프로그래밍 언어(Dynamic Programming Languate)들은 아예 정적 배열 자체가 없다.
파이썬에서도 정적 배열은 따로 제공하지 않으며 동적 배열인 리스트만 제공

동적 배열의 원리

- 미리 초깃값을 작게 잡아 배열을 생성
- 데이터가 추가되면서 꽉 채워지면, 늘려주고 모두 복사
- 대게는 더블링(Doubling)이라 하여 2배씩 늘려주게 되는데,
  당연히 모든 언어가 항상 그런 것은 아니며 언어마다 늘려가는 비율은 상이하다.
- 동적 배열은 정적 배열과 달리 크기를 지정할 필요가 없어 매우 편리하게 활용할 수 있으며, 조회 또한 기존의 배열과 동일하게 O(1)에 가능
- 그러나 더블링이 필요할 만큼 공간이 차게 되면, 새로운 메모리 공간에 더 큰 크기의 배열을 할당하고 기존 데이터를 복사하는 작업이 필요하므로 O(n) 비용이 발생한다. 즉 최악의 경우 삽입 시 O(n)이 되지만 자주 일어나는 일은 아니므로, 4장에서 설명한 대로 분할 상황 분석에 따른 입력 시간(Amorized Insertion Time)은 여전히 O(1)이다. 이처럼 동적 배열은 분할 상환 분석에 따른 시간 복잡도를 설명하는 대표적인 자료형이기도 하다.

7. 두 수의 합
   문제: 덧셈하여 타겟을 만들 수 있는 배열의 두 숫자 인덱스를 리턴하라.
   풀이:

   1. 브루트 포스로 계산
   2. in을 이용한 탐색
   3. 첫 번재 수를 뺀 결과 키 조회
   4. 조회 구조 개선
   5. 투 포인터 이용
      - 투 포인터란 왼쪽 포인터와 오른쪽 포인터의 합이 타겟보다 크다면 오른쪽 포인터를 왼쪽으로, 작다면 왼쪽 포인터를 오른쪽으로 옮기면서 값을 조장하는 방식이다.
      - 이 문제는 투 포인터로 풀 수 없다.
        - 입력값인 nums는 정렬된 상태가 아니기 때문이다.
        - 제대로 풀이하려면 정렬이 필요하다.
        - 그런데 이렇게 하면 인덱스는 모두 엉망이 되기 때문에 매우 심각한 문제가 발생
        - 만약 이 문제가 인덱스가 아니라 값을 찾아내는 문제라면,
          얼마든지 정렬하고 투 포인터로 풀이할 수 있다.
        - 하지만 이처럼 인덱스를 찾아내는 문제에서는 이렇게 정렬을 통해 인덱스를 섞어 버리면 곤란한다. 원래 인덱스를 찾을 수가 없기 때문이다.
   6. 고(Go) 구현

   ```go
   func twoSum(nums []int, target int) []int {
       numsMap := make(map[int]int)

       for i, num := range nums {
           numsMap[num] = i
       }

       for i, num := range nums {
           if j, ok := numsMap[target-num]; ok && i != j {
               return []int{i, j}
           }
       }
   }
   ```

8. 빗물 트래핑
   문제: 높이를 입력받아 비 온 후 얼마나 많은 물이 쌓일 수 있는지 계산하라.
   풀이1: 투 포인터를 최대로 이동

9. 세 수의 합
   문제: 배열을 입력받아 합으로 0을 만들 수 있는 3개의 엘리먼트를 출력하라.

## 참고 투 포인터

- 시작점과 끝점 또는 왼쪽 포인터와 오른쪽 포인터 두 지점을 기준으로 하는 문제 풀이 전략을 뜻한다.
- 범위를 좁혀 나가기 위해서는, 일반적으로 배열이 정렬되어 있을 때 좀 더 유용하다.
- 투 포인터에 대해서는 아직까지 명확하게 제대로 정의된 것이 없다. 투 포인터는 책에 등장하는 내용이 아니라 알고리즘 풀이와 관련해 등장한 실질적인 풀이 기법으로,
  일반적인 알고리즘 교과서에는 등장하지 않는 내용

10. 배옆 파티션I
    문제: n개의 페어를 이용한 min(a, b)의 합으로 만들 수 있는 가장 큰 수를 출력하라.

11. 자신을 제외한 배열의 곱
    문제: 배열을 입력받아 output[i]가 자신을 제외한 나머지 모든 요소의 곱셈 결과가 되도록 출력하라.

12. 주식을 사고팔기 가장 좋은 시점
    문제: 한 번의 거래로 낼 수 있는 최대 이익을 산출하라.
    입력: `[7,1,5,3,6,4]`
    출력: `5`
    설명: 1일 때 사서 6일 때 팔면 5의 이익을 얻는다.

## 파이썬 최댓값과 최솟값

- 최댓값에는 가장 낮은 값을 초깃값으로, 최솟값에는 가장 높은 값은 초깃값으로 해야 어떤 값이든 바로 교체될 수 있다.
- sys를 사용하면 시스템이 지정할 수 있는 가장 높은 값, 낮은 값을 활용할 수 있다.

```py
mx = -sys.maxsize
mn = sys.maxsize
```

- float()을 이용해 무한대 값을 지정하는 방법도 있음

```py
mn = 999999
```

- 파이썬의 숫자형은 임의 정밀도(Arbitary-Precision)를 지원하며 사실상 무한대의 값을 지정할 수 있다.
  아무리 큰 수라 할지라도 얼마든지 더 큰 수가 지정될 수 있으므로,
  이런 식으로 최솟값 변수에 임의의 값을 초깃값으로 지정하는 것은 지양해야 한다.
  얼마든지 더 큰 값이 들어와 최솟값이 교체되지 않을 수 있기 때문이다.
  사실상 sys.maxsize으로 선언하는 것도 파이썬에서는 큰 의미가 없다.
  하지만 일반적인 코딩 테스트의 경우,
  모든 언어에 대응하는 공통된 테스트 케이스로 구성되어 있고,
  따라서 파이썬에서 sys.maxsize로 처리하는 정도만으로도 충분히 모든 테스트 케이스를 통과할 수 있을 것이다.
  대게 코딩 테스트 플랫폼에서는 문제를 자세히 살펴보면, 한쪽 구석에 'n은 0 < n < 5000 사이의 값이다.'와 같은 입력값의 제약 조건이 기술되어 있다.
  이 기준에 맞춰 최댓값과 최솟값을 처리하면 된다.
